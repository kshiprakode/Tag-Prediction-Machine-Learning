{  
   "posts":{  
      "#text":"\n  ",
      "row":[  
         {  
            "@Body":"<p>The set difference operator (e.g., <code>EXCEPT</code> in some SQL variants) is one of the many fundamental operators of relational algebra. However, there are some databases that do not support the set difference operator directly, but which support <code>LEFT JOIN</code> (a kind of outer join), and in practice this can be used instead of a set difference operation to achieve the same effect.</p>\n\n<p>Does this mean that the expressive power of a query language is the same even without the set difference operator, so long as the <code>LEFT JOIN</code> operator is maintained? How would one prove this fact?</p>\n",
            "@ViewCount":"416",
            "#tail":"\n  ",
            "@Title":"Does the 'difference' operation add expressiveness to a query language that already includes 'join'?",
            "@Tags":"<database-theory><relational-algebra><finite-model-theory>",
            "@LastEditorUserId":"69",
            "@LastActivityDate":"2013-05-29T00:50:34.590",
            "@LastEditDate":"2012-04-02T15:35:05.827",
            "@Score":"16",
            "@CommentCount":"1",
            "@AcceptedAnswerId":"28",
            "@PostTypeId":"1",
            "@AnswerCount":"2",
            "@CreationDate":"2012-03-06T19:06:05.667",
            "@FavoriteCount":"1",
            "@Id":"2",
            "@OwnerUserId":"5"
         },
         {  
            "@Body":"<p>In a standard algorithms course we are taught that <strong>quicksort</strong> is $O(n \\log n)$ on average and $O(n^2)$ in the worst case. At the same time, other sorting algorithms are studied which are $O(n \\log n)$ in the worst case (like <strong>mergesort</strong> and <strong>heapsort</strong>), and even linear time in the best case (like <strong>bubblesort</strong>) but with some additional needs of memory.</p>\n\n<p>After a quick glance at <a href=\"http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms\">some more running times</a> it is natural to say that quicksort <strong>should not</strong> be as efficient as others.</p>\n\n<p>Also, consider that students learn in basic programming courses that recursion is not really good in general because it could use too much memory, etc. Therefore (and even though this is not a real argument), this gives the idea that quicksort might not be really good because it is a recursive algorithm.</p>\n\n<p><strong>Why, then, does quicksort outperform other sorting algorithms in practice?</strong> Does it have to do with the structure of <em>real-world data</em>? Does it have to do with the way memory works in computers? I know that some memories are way faster than others, but I don't know if that's the real reason for this counter-intuitive performance (when compared to theoretical estimates).</p>\n\n<hr>\n\n<p><strong>Update 1:</strong> a canonical answer is saying that the constants involved in the $O(n\\log n)$ of the average case are smaller than the constants involved in other $O(n\\log n)$ algorithms. However, I have yet to see a proper justification of this, with precise calculations instead of intuitive ideas only.</p>\n\n<p>In any case, it seems like the real difference occurs, as some answers suggest, at memory level, where implementations take advantage of the internal structure of computers, using, for example, that cache memory is faster than RAM. The discussion is already interesting, but I'd still like to see more detail with respect to memory-management, since it appears that <em>the</em> answer has to do with it.</p>\n\n<hr>\n\n<p><strong>Update 2:</strong> There are several web pages offering a comparison of sorting algorithms, some fancier than others (most notably <a href=\"http://www.sorting-algorithms.com/\">sorting-algorithms.com</a>). Other than presenting a nice visual aid, this approach does not answer my question.</p>\n",
            "@ViewCount":"172527",
            "#tail":"\n  ",
            "@Title":"Why is quicksort better than other sorting algorithms in practice?",
            "@Tags":"<algorithms><sorting>",
            "@LastEditorUserId":"24",
            "@LastActivityDate":"2016-07-19T15:28:19.847",
            "@LastEditDate":"2012-03-23T13:15:39.290",
            "@Score":"187",
            "@CommentCount":"13",
            "@AcceptedAnswerId":"90",
            "@PostTypeId":"1",
            "@AnswerCount":"11",
            "@CreationDate":"2012-03-06T19:11:07.127",
            "@FavoriteCount":"123",
            "@Id":"3",
            "@OwnerUserId":"24"
         },
         {  
            "@Body":"<p>Many operating systems references say that with cooperative (as opposed to preemptive) multitasking, a process keeps the CPU until it explicitly voluntarily suspends itself.  If a running process performs an I/O request that cannot be immediately satisfied (e.g., requests a key stroke that is not yet available), does the scheduler suspend it, or does it really keep the CPU until the request can be serviced?</p>\n\n<p>[Edited to replace \"blocks on i/o\" with \"performs an I/O request that cannot be immediately satisfied.\"]</p>\n",
            "@ViewCount":"1145",
            "#tail":"\n  ",
            "@Title":"Does cooperative scheduling suspend processes when they perform an  I/O operation?",
            "@Tags":"<operating-systems><process-scheduling>",
            "@LastEditorUserId":"98",
            "@LastActivityDate":"2012-04-09T22:15:05.277",
            "@LastEditDate":"2012-04-07T13:42:43.093",
            "@Score":"17",
            "@CommentCount":"2",
            "@AcceptedAnswerId":"12",
            "@PostTypeId":"1",
            "@AnswerCount":"4",
            "@CreationDate":"2012-03-06T19:17:48.460",
            "@FavoriteCount":"0",
            "@Id":"5",
            "@OwnerUserId":"40"
         },
         {  
            "@Body":"<p>When placing geometric objects in a quadtree (or octree), you can place objects that are larger than a single node in a few ways:</p>\n\n<ol>\n<li>Placing the object's reference in every leaf for which it is contained</li>\n<li>Placing the object's reference in the deepest node for which it is fully contained</li>\n<li>Both #1 and #2</li>\n</ol>\n\n<p>For example:</p>\n\n<p><img src=\"http://i.stack.imgur.com/Z2Bj7.jpg\" alt=\"enter image description here\"></p>\n\n<p>In this image, you could either place the circle in all four of the leaf nodes (method #1) or in just the root node (method #2) or both (method #3).</p>\n\n<p>For the purposes of querying the quadtree, which method is more commonplace and why?</p>\n",
            "@ViewCount":"149",
            "#tail":"\n  ",
            "@Title":"Which method is preferred for storing large geometric objects in a quadtree?",
            "@Tags":"<graphics><data-structures><computational-geometry>",
            "@LastEditorUserId":"11",
            "@LastActivityDate":"2012-03-06T20:22:05.510",
            "@LastEditDate":"2012-03-06T19:47:07.427",
            "@Score":"14",
            "@CommentCount":"5",
            "@PostTypeId":"1",
            "@AnswerCount":"2",
            "@CreationDate":"2012-03-06T19:34:22.793",
            "@Id":"7",
            "@OwnerUserId":"11"
         },
         {  
            "@Body":"<p>I have a set of pairs. Each pair is of the form (x,y) such that x,y belong to integers from the range <code>[0,n)</code>.</p>\n\n<p>So, if the n is 4, then I have the following pairs:</p>\n\n<pre><code>(0,1) (0,2) (0,3)\n(1,2) (1,3) \n(2,3) \n</code></pre>\n\n<p>I already have the pairs. Now, I have to build a combination using <code>n/2</code> pairs such that none of the integers are repeated (in other words, each integer appears at least once in the final combination). Following are the examples of a correct and an incorrect combination for better understanding</p>\n\n<pre><code> 1. (0,1)(1,2) [Invalid as 3 does not occur anywhere]\n 2. (0,2)(1,3) [Correct]\n 3. (1,3)(0,2) [Same as 2]\n</code></pre>\n\n<p>Can someone suggest me a way to generate all possible combinations, once I have the pairs.</p>\n",
            "@ViewCount":"4526",
            "#tail":"\n  ",
            "@Title":"Generating Combinations from a set of pairs without repetition of elements",
            "@Tags":"<algorithms>",
            "@LastEditorUserId":"98",
            "@LastActivityDate":"2012-03-07T15:45:01.743",
            "@LastEditDate":"2012-03-07T14:20:14.907",
            "@Score":"22",
            "@CommentCount":"8",
            "@AcceptedAnswerId":"18",
            "@PostTypeId":"1",
            "@AnswerCount":"6",
            "@CreationDate":"2012-03-06T19:54:40.243",
            "@FavoriteCount":"3",
            "@Id":"11",
            "@OwnerUserId":"59"
         }
      ]
   }
}